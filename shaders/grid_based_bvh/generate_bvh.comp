#version 460 core

#define BUCKET_SIZE_DIM 8

layout(local_size_x=BUCKET_SIZE_DIM, local_size_y=BUCKET_SIZE_DIM) in;


#define BVH_V2_METADATA_BBOX            0
#define BVH_V2_METADATA_LINE_BUCKET     1
#define BVH_V2_NODE_FLOAT4_STRIDE       3

readonly layout(std430, binding = 0) buffer inLines_ { vec4 inLines[]; };
writeonly layout(std430, binding = 1) buffer outBVH_ { vec4 outBVH[]; };


#define MAKE_LINEAR_ID(tid, brickSize) ((tid).y * (brickSize) + (tid).x)


layout(location=0) uniform uint numLines;


vec4 mergeBounds(vec4 a, vec4 b)
{
    return vec4(min(a.xy, b.xy), max(a.zw, b.zw));
}

float boundsArea(vec4 a)
{
    vec2 deriv = a.zw - a.xy;
    return max(0, deriv.x * deriv.y);
}


struct BVHNodeEntry
{
    uint type;
    uint offset;
    vec4 bbox;
    uint count;
};

BVHNodeEntry makeTopLevelBVHEntry(uint offset, vec4 bbox, uint count)
{
    BVHNodeEntry result;
    result.type = BVH_V2_METADATA_LINE_BUCKET;
    result.offset = offset | (count << 24);
    result.bbox = bbox;
    result.count = count;
    return result;
}


BVHNodeEntry writeBVHNode(uint outputOffset,
                          BVHNodeEntry left,
                          BVHNodeEntry right)
{
    // NB: we could avoid writing invalid entries
    // and possibly saving some bandwith
    outBVH[outputOffset] = uintBitsToFloat(uvec4(
        left.type, left.offset, right.type, right.offset
    ));
    outBVH[outputOffset + 1] = left.count == 0 ? vec4(0) : left.bbox;
    outBVH[outputOffset + 2] = right.count == 0 ? vec4(0) : right.bbox;

    // If we didn't do a proper merge, just return which
    // ever value was valid, or return an invalid value
    // if neither were valid. 
    if(left.count == 0)         { return right; }
    else if(right.count == 0)   { return left; }

    BVHNodeEntry merged;
    merged.type = BVH_V2_METADATA_BBOX;
    merged.offset = outputOffset;
    merged.count = left.count + right.count;
    merged.bbox = mergeBounds(left.bbox, right.bbox);
    return merged;
}

BVHNodeEntry writeBVHLevel(uint outputOffset,
                           BVHNodeEntry A, BVHNodeEntry B,
                           BVHNodeEntry C, BVHNodeEntry D)
{
    // Pick either [[A B] | [C D]]
    //          or [[A C] | [B D]]
    float ABarea = boundsArea(mergeBounds(A.bbox, B.bbox));
    float ACarea = boundsArea(mergeBounds(A.bbox, C.bbox));
    float CDarea = boundsArea(mergeBounds(C.bbox, D.bbox));
    float BDarea = boundsArea(mergeBounds(B.bbox, D.bbox));
    if((ABarea + CDarea) > (ACarea + BDarea))
    {
        BVHNodeEntry tmp = B;
        B = C;
        C = tmp;
    }

    BVHNodeEntry left = writeBVHNode(outputOffset + BVH_V2_NODE_FLOAT4_STRIDE,
                                     A, B);
    BVHNodeEntry right = writeBVHNode(outputOffset + BVH_V2_NODE_FLOAT4_STRIDE * 2,
                                     C, D);
    return writeBVHNode(outputOffset, left, right);
}

shared uint bucketAllocator[BUCKET_SIZE_DIM * BUCKET_SIZE_DIM];
shared BVHNodeEntry nodeDataSwapA[BUCKET_SIZE_DIM * BUCKET_SIZE_DIM];
shared BVHNodeEntry nodeDataSwapB[(BUCKET_SIZE_DIM / 2) * (BUCKET_SIZE_DIM / 2)];



void main()
{
    uvec2 tid = gl_LocalInvocationID.xy;
    uint bucketId = MAKE_LINEAR_ID(tid, BUCKET_SIZE_DIM);
    
    // We bucket lines based upon where their center is.
    vec4 bucketBbox = vec4(tid, tid + 1u) /
                      vec2(BUCKET_SIZE_DIM - 1, BUCKET_SIZE_DIM - 1).xyxy;


    // This is the final bbox of the current cell, which starts
    // of as being invalid, but as we find relevant lines, we will
    // expand it to fit them all.
    vec4 finalBbox = vec4(1.0, 1.0, -1.0, -1.0);

    // Keep track of how many lines we need to home and the first and last
    // line id (to make it quicker to iterate over).
    uint bucketCount = 0u;
    uint firstLine = 0u;
    uint endLine = 0u;

    for(uint lineId = 0; lineId < numLines; ++lineId)
    {
        vec4 line = inLines[lineId];
        vec2 center = (line.xy + line.zw) * 0.5;
        if(all(greaterThanEqual(center.xy, bucketBbox.xy))
           && all(lessThan(center.xy, bucketBbox.zw)))
        {
            if(bucketCount == 0)
            {
                firstLine = lineId;
            }
            endLine = lineId + 1u;

            vec4 lineBbox = vec4(min(line.xy, line.zw), max(line.xy, line.zw));
            finalBbox = mergeBounds(finalBbox, lineBbox);

            ++bucketCount;
        }
    }

    bucketAllocator[bucketId] = bucketCount;
    barrier();

#if DEBUG_LEVEL == 1
    // debugging
    if(bucketCount == 0)
    {
        finalBbox = vec4(0);
    }
    outBVH[bucketId] = finalBbox;
    return;
#endif // DEBUG_LEVEL == 1

    // Next we need to figure out what the offset
    // this bucket should start writing 

    const uint nodeOffsetLevel0 = 0u;
    const uint nodeSizeLevel0 = 3u * BVH_V2_NODE_FLOAT4_STRIDE;

    const uint nodeOffsetLevel1 = nodeOffsetLevel0 + nodeSizeLevel0;
    const uint nodeSizeLevel1 = 4u * nodeSizeLevel0;

    const uint nodeOffsetLevel2 = nodeOffsetLevel1 + nodeSizeLevel1;
    const uint nodeSizeLevel2 = 4u * nodeSizeLevel1;

    const uint bucketLinesStartOffset = nodeOffsetLevel2 + nodeSizeLevel2;


    uint bucketWriteOffset = bucketLinesStartOffset;
    for(uint id=0; id<bucketId; ++id)
    {
        bucketWriteOffset += bucketAllocator[id];
    }
    nodeDataSwapA[bucketId] = makeTopLevelBVHEntry(bucketWriteOffset,
                                                   finalBbox,
                                                   bucketCount);


    barrier();

    // Write out lines into their respective places
    for(uint lineId = firstLine; lineId < endLine; ++lineId)
    {
        vec4 line = inLines[lineId];
        vec2 center = (line.xy + line.zw) * 0.5;
        if(all(greaterThanEqual(center.xy, bucketBbox.xy))
           && all(lessThan(center.xy, bucketBbox.zw)))
        {
            outBVH[bucketWriteOffset++] = vec4(line.xy, line.xy - line.zw);
        }
    }

    if(all(lessThan(tid, uvec2(BUCKET_SIZE_DIM/2))))
    {
        uint localBucketId = MAKE_LINEAR_ID(tid, BUCKET_SIZE_DIM/2);
        uint Aid = MAKE_LINEAR_ID((tid * 2u + uvec2(0, 0)), BUCKET_SIZE_DIM);
        uint Bid = MAKE_LINEAR_ID((tid * 2u + uvec2(1, 0)), BUCKET_SIZE_DIM);
        uint Cid = MAKE_LINEAR_ID((tid * 2u + uvec2(0, 1)), BUCKET_SIZE_DIM);
        uint Did = MAKE_LINEAR_ID((tid * 2u + uvec2(1, 1)), BUCKET_SIZE_DIM);

        BVHNodeEntry A = nodeDataSwapA[Aid];
        BVHNodeEntry B = nodeDataSwapA[Bid];
        BVHNodeEntry C = nodeDataSwapA[Cid];
        BVHNodeEntry D = nodeDataSwapA[Did];

#if DEBUG_LEVEL == 2
        // debugging
        vec4 topLevelBbox = mergeBounds(mergeBounds(A.bbox, B.bbox),
                                        mergeBounds(C.bbox, D.bbox));
        if((A.count + B.count + C.count + D.count) == 0)
        {
            topLevelBbox = vec4(0);
        }
        outBVH[localBucketId] = topLevelBbox;
        return;
#endif // DEBUG_LEVEL == 2

        nodeDataSwapB[localBucketId] = writeBVHLevel(nodeOffsetLevel2 + 3 * BVH_V2_NODE_FLOAT4_STRIDE * localBucketId,
                                                     A, B, C, D);
    }
    barrier();

    if(all(lessThan(tid, uvec2(BUCKET_SIZE_DIM/4))))
    {
        uint localBucketId = MAKE_LINEAR_ID(tid, BUCKET_SIZE_DIM/4);
        uint Aid = MAKE_LINEAR_ID((tid * 2u + uvec2(0, 0)), BUCKET_SIZE_DIM/2);
        uint Bid = MAKE_LINEAR_ID((tid * 2u + uvec2(1, 0)), BUCKET_SIZE_DIM/2);
        uint Cid = MAKE_LINEAR_ID((tid * 2u + uvec2(0, 1)), BUCKET_SIZE_DIM/2);
        uint Did = MAKE_LINEAR_ID((tid * 2u + uvec2(1, 1)), BUCKET_SIZE_DIM/2);

        BVHNodeEntry A = nodeDataSwapB[Aid];
        BVHNodeEntry B = nodeDataSwapB[Bid];
        BVHNodeEntry C = nodeDataSwapB[Cid];
        BVHNodeEntry D = nodeDataSwapB[Did];

#if DEBUG_LEVEL == 3
        // debugging
        vec4 topLevelBbox = mergeBounds(mergeBounds(A.bbox, B.bbox),
                                        mergeBounds(C.bbox, D.bbox));
        if((A.count + B.count + C.count + D.count) == 0)
        {
            topLevelBbox = vec4(0);
        }
        outBVH[localBucketId] = topLevelBbox;
        return;
#endif // DEBUG_LEVEL == 3

        nodeDataSwapA[localBucketId] = writeBVHLevel(nodeOffsetLevel1 + 3 * BVH_V2_NODE_FLOAT4_STRIDE * localBucketId,
                                                     A, B, C, D);
    }
    barrier();

    if(all(lessThan(tid, uvec2(BUCKET_SIZE_DIM/8))))
    {
        uint localBucketId = MAKE_LINEAR_ID(tid, BUCKET_SIZE_DIM/8);
        uint Aid = MAKE_LINEAR_ID((tid * 2u + uvec2(0, 0)), BUCKET_SIZE_DIM/4);
        uint Bid = MAKE_LINEAR_ID((tid * 2u + uvec2(1, 0)), BUCKET_SIZE_DIM/4);
        uint Cid = MAKE_LINEAR_ID((tid * 2u + uvec2(0, 1)), BUCKET_SIZE_DIM/4);
        uint Did = MAKE_LINEAR_ID((tid * 2u + uvec2(1, 1)), BUCKET_SIZE_DIM/4);

        BVHNodeEntry A = nodeDataSwapA[Aid];
        BVHNodeEntry B = nodeDataSwapA[Bid];
        BVHNodeEntry C = nodeDataSwapA[Cid];
        BVHNodeEntry D = nodeDataSwapA[Did];

        writeBVHLevel(nodeOffsetLevel0 + 3 * BVH_V2_NODE_FLOAT4_STRIDE * localBucketId,
                      A, B, C, D);
    }

}
