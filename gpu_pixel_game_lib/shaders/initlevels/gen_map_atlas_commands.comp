#version 460 core


#define NUM_THREADS 64

layout(local_size_x=NUM_THREADS) in;


#include "../common.glsli"
#include "../map_atlas_common.glsli"
#include "mapgen_common.glsli"


layout(set=0, binding = 0) uniform GlobalParameters_
{
    GlobalParameters globals;
}; 

// SHOULD BE IN ANOTHER SET FOR VULKAN THINGS
writeonly layout(std430, binding = 1) buffer drawCmds_      { uvec2 outDrawCmds[]; };
writeonly layout(std430, binding = 2) buffer drawAllocator_ { uint drawAllocator[]; };


uint allocateDrawCommands(uint num)
{
    return atomicAdd(drawAllocator[0], num * 6u) / 6u;
}


struct DrawQueue
{
    ivec4 span;

    /// TODO
    //  add flags to spawn playerand exit into rooms, passing
    //  the flag down to the lowest leaf
    // int spawnPlayer;
    // int spawnExit;
};


shared DrawQueue    bspQueue[NUM_THREADS/2];


// Uses the last 23bits to construct a linear range
// [0, 1) = [0.375, 0.625)
float randomBounded0125(uint seed)
{
    // 1x shift_add
    // 1x add
    seed = 0x3e800000u + (seed & 0x7fffffu);
    return uintBitsToFloat(seed) + 0.125f;
}


uint bspSplit(const DrawQueue parent,
              inout DrawQueue left,
              inout DrawQueue right,
              uint randomSeed)
{
    ivec2 dims = parent.span.zw - parent.span.xy;

    // uint seed = simpleHash32(uvec3(globals.cpuRandom, it, tid));
    float splitAmount = randomBounded0125(randomSeed);

    // Randomise split direction if both width and height are equal
    // otherwise, split whichever is bigger.
    uint splitDirection = (dims.x == dims.y) 
                            ? (randomSeed >> 23) & 1u
                            : dims.x < dims.y
                                ? 1u : 0u
                            ;
    left = parent;
    right = parent;

    const int padding = 1;

    // Split across X
    if(splitDirection == 0u)
    {
        left.span.z = left.span.x + int((float(dims.x) + 0.5) * splitAmount);
        right.span.x = left.span.z;
        left.span.x += padding;
        left.span.z -= padding;
        right.span.x += padding;
        right.span.z -= padding;
    }
    // Split across Y
    else
    {
        left.span.w = left.span.y + int((float(dims.y) + 0.5) * splitAmount);
        right.span.y = left.span.w;
        left.span.y += padding;
        left.span.w -= padding;
        right.span.y += padding;
        right.span.w -= padding;
    }

    return splitDirection;
}


void main()
{
    uint tid = gl_LocalInvocationID.x;
    MapAtlasLevelInfo atlasInfo = getLevelAtlasInfo(gl_GlobalInvocationID.z);

    // Root node, which encompasses the entire level
    if(tid == 0u)
    {
        DrawQueue newQueue;
        newQueue.span = ivec4(atlasInfo.offset.x,
                              atlasInfo.offset.y,
                              atlasInfo.offset.x + atlasInfo.size.x,
                              atlasInfo.offset.y + atlasInfo.size.y);
        bspQueue[0] = newQueue;
    }
    barrier();

    // Keep splitting the BSP, and adding draw commands for paths
    // that connect both sides
    for(uint it=1u; it<(NUM_THREADS/2); it<<=1)
    {
        if(tid < it)
        {
            DrawQueue parent = bspQueue[tid];
            uint splitSeed = simpleHash32(uvec3(globals.cpuRandom, it, tid));

            DrawQueue left, right;
            uint splitDirection = bspSplit(parent, left, right, splitSeed);

            // Make sure the split is valid.
            ivec2 leftDeriv = left.span.zw - left.span.xy;
            ivec2 rightDeriv = right.span.zw - right.span.xy;
            int leftArea = leftDeriv.x * leftDeriv.y;
            int rightArea = rightDeriv.x * rightDeriv.y;

            if((leftDeriv.x >= atlasInfo.minDim)
                && (leftDeriv.y >= atlasInfo.minDim)
                && (rightDeriv.x >= atlasInfo.minDim)
                && (rightDeriv.y >= atlasInfo.minDim)
                && (leftArea >= atlasInfo.minArea)
                && (rightArea >= atlasInfo.minArea))
            {

                // Update the parents slot in the queue with the left node
                // and then create a path between the centers of the two
                // leaf nodes
                bspQueue[tid] = left;
                vec2 leftCenter = vec2(left.span.xy)
                                  + vec2(leftDeriv) * 0.5
                                  + 0.5
                                  ;

                vec2 rightCenter = vec2(right.span.xy)
                                  + vec2(rightDeriv) * 0.5
                                  + 0.5
                                  ;

                vec4 path = (splitDirection == 0)
                    ? vec4(vec2(leftCenter.x, rightCenter.y), rightCenter + 1.0)
                    : vec4(leftCenter, vec2(leftCenter.x, rightCenter.y) + 1.0)
                    ;

                ivec4 pathSpan = ivec4(path);
                uint pathIndex = allocateDrawCommands(2u);

                outDrawCmds[pathIndex + 0u] = packDrawCommand(pathSpan,
                                                              MAP_ATLAS_WALL_ID_FLOOR,
                                                              MAP_ATLAS_WALL_DEPTH_FLOOR);

                outDrawCmds[pathIndex + 1u] = packDrawCommand(pathSpan + ivec4(0, 1, 0, 1),
                                                              MAP_ATLAS_WALL_ID_WALL,
                                                              MAP_ATLAS_WALL_DEPTH_WALL);

            }
            else
            {
                // Leave the parents data (left node) alone, either it will be split
                // the next iteration, or it will become a leaf.
                right.span = ivec4(0, 0, 0, 0);
            }

            bspQueue[it + tid] = right;
        }
        barrier();
    }


    // Write out actual leafs
    DrawQueue leaf = bspQueue[tid];
    if(leaf.span.x != leaf.span.z)
    {

        // Floor and walll
        uint numberOfCommands = 2u;

        // TODO:
        //  This is where we would scatter
        //  enemies, add bonfires, the players
        //  spawn and exit, loot etc.

        uint commandsIndex = allocateDrawCommands(numberOfCommands);
        outDrawCmds[commandsIndex++] = packDrawCommand(leaf.span,
                                                       MAP_ATLAS_WALL_ID_FLOOR,
                                                       MAP_ATLAS_WALL_DEPTH_FLOOR);
        outDrawCmds[commandsIndex++] = packDrawCommand(ivec4(leaf.span.x,
                                                             max(leaf.span.y, leaf.span.w),
                                                             leaf.span.z,
                                                             max(leaf.span.y, leaf.span.w) + 1),
                                                       MAP_ATLAS_WALL_ID_WALL,
                                                       MAP_ATLAS_WALL_DEPTH_WALL);

        // And this is where we would write out the other commands

    }
}
