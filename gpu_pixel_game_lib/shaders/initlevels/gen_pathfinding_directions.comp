#version 460 core


#define NUM_THREADS             64

// I don't have an especially good basis for deriving this,
// when manually testing, I've found that after 64 iterations
// on the biggest 64x64 map, all paths are fully resolved.
// The use of 128, is purely to be super-duper sure we have
// reliably solved all possible paths.
#define NUM_FLOOD_FILL_ITERS    128


#define HALF_MAX_LEVEL_DIM_SHARED_SIZE (MAX_LEVEL_DIM_SHARED_SIZE/2)

layout(local_size_x=NUM_THREADS) in;


#include "../common.glsli"
#include "../map_atlas_common.glsli"
#include "../pathfinding_common.glsli"


layout(set=0, binding = 0) uniform GlobalParameters_
{
    GlobalParameters globals;
}; 


readonly layout(binding=1, r32ui)    uniform uimage2D mapAtlas;
         layout(binding=2, rg32ui)   uniform uimage2D roomDirections;


// This shader generates an atlas of directions to travel to get
// to rooms.
// Per pixel, we keep track of which rooms have a path to them, using a bitmask
// we then do two passes.
//
// In a 1 pixel flood fill kind of way, if any neighbour has a path to a room
// that we currently don't have a path to, we update the roomDirection to point
// to it and mark the current pixel as having a valid direction.
//
// We evaluate pixels in a checkboard formations:
//
// X . X              . X .
// . X .    and then  X . X
// X . X              . X .


shared uint roomPathMask[MAX_LEVEL_DIM_SHARED_SIZE * MAX_LEVEL_DIM_SHARED_SIZE];


uint sampleRoomPathMaskUnguarded(ivec2 coord)
{
    return roomPathMask[coord.x + coord.y * MAX_LEVEL_DIM_SHARED_SIZE];
}

uint sampleRoomPathMask(ivec2 coord)
{
    if(min(coord.x, coord.y) >=0 && max(coord.x, coord.y) < MAX_LEVEL_DIM_SHARED_SIZE)
    {
        return sampleRoomPathMaskUnguarded(coord);
    }
    return 0u;
}


uint generatePathMask(uint pixelId, int targetUpperBits)
{
    uvec4 sectorIds = unpackSectorIds(pixelId);
    uint pathMask = 0u;
    do
    {
        if(sectorIds.x == 0u) { break; }
        if((--sectorIds.x >= 32u) == (targetUpperBits == 1))
        {
            if(targetUpperBits == 1) { sectorIds.x -= 32; }
            pathMask = 1u << sectorIds.x;
        }

        if(sectorIds.y == 0u) { break; }
        if((--sectorIds.y >= 32u) == (targetUpperBits == 1))
        {
            if(targetUpperBits == 1) { sectorIds.y -= 32; }
            pathMask |= 1u << sectorIds.y;
        }

        if(sectorIds.z == 0u) { break; }
        if((--sectorIds.z >= 32u) == (targetUpperBits == 1))
        {
            if(targetUpperBits == 1) { sectorIds.z -= 32; }
            pathMask |= 1u << sectorIds.z;
        }

        if(sectorIds.w == 0u) { break; }
        if((--sectorIds.w >= 32u) == (targetUpperBits == 1))
        {
            if(targetUpperBits == 1) { sectorIds.w -= 32; }
            pathMask |= 1u << sectorIds.w;
        }
    }
    while(false);
    return pathMask;
}


// Initialises the room path masks and room directions to a state of 0.
void init(uint tid, MapAtlasLevelInfo atlasInfo, int targetUpperBits)
{

    // Initialise the path mask with an initial state of having seen the current room
    // and clear roomDirections are the relevant locations.
    for(uint it = tid; it < (MAX_LEVEL_DIM_SHARED_SIZE * MAX_LEVEL_DIM_SHARED_SIZE); it += NUM_THREADS)
    {
        ivec2 localCoord = ivec2(uvec2(it % MAX_LEVEL_DIM_SHARED_SIZE, it / MAX_LEVEL_DIM_SHARED_SIZE))
                            + ivec2(MAX_LEVEL_DIM_SHARED_OFFSET);

        uint pathMask = 0u;
        if(localCoord.x < atlasInfo.size.x && localCoord.y < atlasInfo.size.y)
        {
            ivec2 atlasOffset = ivec2(localCoord + atlasInfo.offset);
            ivec2 dirAtlasOffset = atlasOffset * ivec2(2, 1) + ivec2(targetUpperBits, 0);

            imageStore(roomDirections, dirAtlasOffset, uvec4(0));
            uint pixelId = imageLoad(mapAtlas, atlasOffset).x;
            pathMask = generatePathMask(pixelId, targetUpperBits);
        }
        roomPathMask[it] = pathMask;
    }
    barrier();
}


#if (MAX_LEVEL_DIM_SHARED_SIZE * MAX_LEVEL_DIM_SHARED_SIZE) > (NUM_THREADS * 64)
#error "using uvec2 isn't enough storage space per pixel for valid pixel mask!"
#endif // (MAX_LEVEL_DIM_SHARED_SIZE * MAX_LEVEL_DIM_SHARED_SIZE) > (NUM_THREADS * 64)// 


bool testValidPixelCoord(uvec2 sharedCoord, MapAtlasLevelInfo atlasInfo)
{
    sharedCoord += MAX_LEVEL_DIM_SHARED_OFFSET;
    if(sharedCoord.x < atlasInfo.size.x && sharedCoord.y < atlasInfo.size.y)
    {
        ivec2 atlasOffset = ivec2(sharedCoord + atlasInfo.offset);
        return imageLoad(mapAtlas, atlasOffset).x != 0u;
    }
    return false;
}


uvec2 generateValidPixelMask(uint tid, MapAtlasLevelInfo atlasInfo)
{
    uvec2 validPixelMask = uvec2(0);
    uint i = 0;

    for(uint it = tid; it < (MAX_LEVEL_DIM_SHARED_SIZE * HALF_MAX_LEVEL_DIM_SHARED_SIZE); it += NUM_THREADS, ++i)
    {
        // First checkerboard pattern
        uvec2 coord0 = uvec2((it % HALF_MAX_LEVEL_DIM_SHARED_SIZE) * 2, it / HALF_MAX_LEVEL_DIM_SHARED_SIZE);
              coord0.x ^= (coord0.y & 1u);

        // Second checkerboard pattern
        uvec2 coord1 = coord0;
              coord1.x ^= 1u;

        if(testValidPixelCoord(coord0, atlasInfo)) { validPixelMask.x |= (1u << i); }
        if(testValidPixelCoord(coord1, atlasInfo)) { validPixelMask.y |= (1u << i); }
    }

    return validPixelMask;
}


// Duplicats each bit twice
// e.g:
//  0b1010 => 0b11001100
//  0b1100 => 0b11110000
//  0b1001 => 0b11000011
uint duplicateBits2(uint x)
{
    x = (x | (x << 8)) & 0x00ff00ffu;
    x = (x | (x << 4)) & 0x0f0f0f0fu;
    x = (x | (x << 2)) & 0x33333333u;
    x = (x | (x << 1)) & 0x55555555u;
    return x | (x << 1);
}

void updateFromNeighbour(uint mask,
                         inout uint updated,
                         inout uvec2 updatedDirection,
                         const uint directionMask)
{
    if(mask != 0u)
    {
        // static analysis away LEFT
        if(directionMask != 0u)
        {            
            updatedDirection.x |= directionMask & duplicateBits2(mask & 0xffffu);
            updatedDirection.y |= directionMask & duplicateBits2(mask >> 16u);
        }
        updated |= mask;
    }
}


void directFloorColumn(uint tid,
                       MapAtlasLevelInfo atlasInfo,
                       int targetUpperBits)
{
    int width = int(atlasInfo.size.x) - MAX_LEVEL_DIM_SHARED_OFFSET;
    int height = int(atlasInfo.size.y) - MAX_LEVEL_DIM_SHARED_OFFSET;
    int x = int(tid);
    if(x < width)
    {
        uint mask = 0;
        for(int y=0; y<height; ++y)
        {
            ivec2 coord = ivec2(x, y);

            if(!testValidPixelCoord(uvec2(coord), atlasInfo))
            {
                mask = 0u;
                continue;
            }

            uint self = sampleRoomPathMaskUnguarded(coord);
            uint updated = self;
            uvec2 updatedDirection = uvec2(0);
            updateFromNeighbour(mask & ~updated, updated, updatedDirection, PATHFINDING_DOWN_MASK);
            mask |= self;

            if(self != updated)
            {
                ivec2 atlasOffset = coord + ivec2(atlasInfo.offset + MAX_LEVEL_DIM_SHARED_OFFSET);
                ivec2 dirAtlasOffset = atlasOffset * ivec2(2, 1) + ivec2(targetUpperBits, 0);

                updatedDirection |= imageLoad(roomDirections, dirAtlasOffset).xy;
                imageStore(roomDirections, dirAtlasOffset, updatedDirection.xyxy);
                roomPathMask[coord.y * MAX_LEVEL_DIM_SHARED_SIZE + coord.x] = updated;
            }
        }

        for(int y=height-1; y>=0; --y)
        {
            ivec2 coord = ivec2(x, y);

            if(!testValidPixelCoord(uvec2(coord), atlasInfo))
            {
                mask = 0u;
                continue;
            }

            uint self = sampleRoomPathMaskUnguarded(coord);
            uint updated = self;
            uvec2 updatedDirection = uvec2(0);
            updateFromNeighbour(mask & ~updated, updated, updatedDirection, PATHFINDING_UP_MASK);
            mask |= self;

            if(self != updated)
            {
                ivec2 atlasOffset = coord + ivec2(atlasInfo.offset + MAX_LEVEL_DIM_SHARED_OFFSET);
                ivec2 dirAtlasOffset = atlasOffset * ivec2(2, 1) + ivec2(targetUpperBits, 0);

                updatedDirection |= imageLoad(roomDirections, dirAtlasOffset).xy;
                imageStore(roomDirections, dirAtlasOffset, updatedDirection.xyxy);
                roomPathMask[coord.y * MAX_LEVEL_DIM_SHARED_SIZE + coord.x] = updated;
            }
        }
    }
    barrier();
}


void directionFloorItChecker(uint tid,
                             MapAtlasLevelInfo atlasInfo,
                             uint validPixelMask, 
                             uint side,
                             int targetUpperBits)
{
    while(validPixelMask != 0u)
    {
        uint bit = findLSB(validPixelMask);
        validPixelMask -= (1u << bit);
        uint it = tid + bit * NUM_THREADS;

        uvec2 coord = uvec2((it % HALF_MAX_LEVEL_DIM_SHARED_SIZE) * 2, it / HALF_MAX_LEVEL_DIM_SHARED_SIZE);
              coord.x ^= (coord.y & 1u) ^ side;

        uint self = sampleRoomPathMask(ivec2(coord));
        uint left = sampleRoomPathMask(ivec2(coord) + decodePathDirection(PATHFINDING_LEFT));
        uint right = sampleRoomPathMask(ivec2(coord) + decodePathDirection(PATHFINDING_RIGHT));
        uint down = sampleRoomPathMask(ivec2(coord) + decodePathDirection(PATHFINDING_DOWN));
        uint up = sampleRoomPathMask(ivec2(coord) + decodePathDirection(PATHFINDING_UP));


        if((self | left | up | down | right) == self)
        {
            continue;
        }

        uint updated = self;
        uvec2 updatedDirection = uvec2(0);

        uvec2 first = uvec2(left, PATHFINDING_LEFT_MASK);
        uvec2 second = uvec2(right, PATHFINDING_RIGHT_MASK);
        uvec2 third = uvec2(up, PATHFINDING_UP_MASK);
        uvec2 fourth = uvec2(down, PATHFINDING_DOWN_MASK);

        updateFromNeighbour(first.x & ~updated, updated, updatedDirection, first.y);
        updateFromNeighbour(second.x & ~updated, updated, updatedDirection, second.y);
        updateFromNeighbour(third.x & ~updated, updated, updatedDirection, third.y);
        updateFromNeighbour(fourth.x & ~updated, updated, updatedDirection, fourth.y);

        if(updated != self)
        {
            ivec2 atlasOffset = ivec2(coord + atlasInfo.offset + MAX_LEVEL_DIM_SHARED_OFFSET);
            ivec2 dirAtlasOffset = atlasOffset * ivec2(2, 1) + ivec2(targetUpperBits, 0);

            updatedDirection |= imageLoad(roomDirections, dirAtlasOffset).xy;
            imageStore(roomDirections, dirAtlasOffset, updatedDirection.xyxy);
            roomPathMask[coord.y * MAX_LEVEL_DIM_SHARED_SIZE + coord.x] = updated;
        }

    }

    barrier();
}


void directionFloorIt(uint tid, MapAtlasLevelInfo atlasInfo, uvec2 validPixelMask, int targetUpperBits)
{
    directionFloorItChecker(tid, atlasInfo, validPixelMask.x, 0u, targetUpperBits);
    directionFloorItChecker(tid, atlasInfo, validPixelMask.y, 1u, targetUpperBits);
}


void main()
{
    uint tid = gl_LocalInvocationID.x;
    int targetUpperBits = int(gl_GlobalInvocationID.z & 1u);
    MapAtlasLevelInfo atlasInfo = getLevelAtlasInfo(gl_GlobalInvocationID.z / 2);
    
    init(tid, atlasInfo, targetUpperBits);

    // We do an initial vertical fill to coounter the directional bias, that occurs
    // when implicitly filling.
    //
    // The following directions take priority:
    //  L, R, U, D
    //
    // So it's possible to have this sort of pattern emerge
    //
    // v < v < v
    // X X X X X
    //
    // Due to the checkerboard evaluating every other pixel down,
    // then alternating and picking the left direction first.
    directFloorColumn(tid, atlasInfo, targetUpperBits);

    uvec2 validPixelMask = generateValidPixelMask(tid, atlasInfo);

    for(uint i=0; i<NUM_FLOOD_FILL_ITERS; ++i)
    {
        directionFloorIt(tid, atlasInfo, validPixelMask, targetUpperBits);
    }
}
