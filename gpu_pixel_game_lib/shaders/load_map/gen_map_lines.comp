#version 460 core

// TODO
// CHANGE THIS TO BE IN RENDER BUFFER SPACE
// SO DISTANCES N STUFF ARE GLOBAL, RATHER THAN
// RELATIVE TO THE MAP SIZE!


#include "../common.glsli"
#include "../map_atlas_common.glsli"


#define THREAD_SIZE         MAX_LEVEL_DIM
#define INVALID_OFFSET      -0x7ffffff
#define UV_OFFSET_BASE      (0.125)
#define UV_OFFSET_INVBASE   (1.-0.125)
#define UV_OFFSET_AMOUNT    (0.25 * 1.5)
#define UV_Y_OFFSET         (0.25 * 1.5)


layout(local_size_x=THREAD_SIZE) in;


layout(set=0, binding = 0) uniform GlobalParameters_
{
    GlobalParameters globals;
}; 


readonly layout (r32ui, binding = 1)  uniform uimage2D mapAtlas;
writeonly layout(std430, binding = 2) buffer outNumLines_ { uint outNumLines; };
writeonly layout(std430, binding = 3) buffer outLines_ { vec4 outLines[]; };


shared uint lineAllocator[THREAD_SIZE];


bool sampleCoord(ivec2 localCoord, MapAtlasLevelInfo atlasInfo)
{
    if(localCoord.x < atlasInfo.size.x
        && localCoord.x >= 0
        && localCoord.y < atlasInfo.size.y
        && localCoord.y >= 0)
    {
        ivec2 coord = localCoord + ivec2(atlasInfo.offset);
        return hasAnySectors(imageLoad(mapAtlas, coord).x);
    }
    return false;
}


uint evaluateHorizontal(uint tid,
                        uint offset,
                        MapAtlasLevelInfo atlasInfo,
                        bool dryRun)
{
    float invWidth = atlasInfo.inverseSize.x;
    float invHeight = atlasInfo.inverseSize.y;

    for(int y=int(tid); y < atlasInfo.size.y; y+=THREAD_SIZE)
    {
        int lineStart = INVALID_OFFSET;
        float u0Offset = 0;
        float v = 0;

        for(int x=0; x < atlasInfo.size.x; ++x)
        {
            bool downVisible = sampleCoord(ivec2(x, y-1), atlasInfo);
            bool middleVisible = sampleCoord(ivec2(x, y), atlasInfo);

            if(downVisible != middleVisible)
            {
                if(lineStart == INVALID_OFFSET)
                {
                    float voffset = (downVisible ? UV_OFFSET_AMOUNT : -UV_OFFSET_AMOUNT);
                    v = (float(y) + voffset + UV_Y_OFFSET) * invHeight;

                    lineStart = x;
                    
                    bool leftVisible = sampleCoord(ivec2(x-1, y), atlasInfo);
                    u0Offset = (leftVisible ? UV_OFFSET_AMOUNT : -UV_OFFSET_AMOUNT)
                                + UV_OFFSET_BASE
                                ;

                }
            }
            else if(lineStart != INVALID_OFFSET)
            {
                uint writeId = offset++;
                if(!dryRun)
                {
                    uint lineEnd = x;

                    float u0 = (float(lineStart) + u0Offset) * invWidth;

                    float u1Offset = (middleVisible ? -UV_OFFSET_AMOUNT : UV_OFFSET_AMOUNT)
                                    - UV_OFFSET_BASE
                                    ;
                    float u1 = (float(lineEnd) + u1Offset) * invWidth;

                    outLines[writeId] = vec4(u0,
                                             v,
                                             u1,
                                             v);
                }
                lineStart = INVALID_OFFSET;
            }
        }
    }

    return offset;
}


uint evaluateVertical(uint tid,
                     uint offset,
                     MapAtlasLevelInfo atlasInfo,
                     bool dryRun)
{
    float invWidth = atlasInfo.inverseSize.x;
    float invHeight = atlasInfo.inverseSize.y;

    for(int x=int(tid); x < atlasInfo.size.x; x+=THREAD_SIZE)
    {
        int lineStart = INVALID_OFFSET;
        float v0Offset = 0;
        float u = 0;

        for(int y=0; y < atlasInfo.size.y; ++y)
        {
            bool leftVisible = sampleCoord(ivec2(x-1, y), atlasInfo);
            bool middleVisible = sampleCoord(ivec2(x, y), atlasInfo);

            if(leftVisible != middleVisible)
            {
                if(lineStart == INVALID_OFFSET)
                {
                    float uoffset = (leftVisible ? UV_OFFSET_AMOUNT : -UV_OFFSET_AMOUNT);
                    u = (float(x) + uoffset) * invWidth;

                    lineStart = y;

                    bool downVisible = sampleCoord(ivec2(x, y-1), atlasInfo);
                    v0Offset = (downVisible ? UV_OFFSET_AMOUNT : -UV_OFFSET_AMOUNT)
                                + UV_OFFSET_BASE
                                + UV_Y_OFFSET
                                ;

                }
            }
            else if(lineStart != INVALID_OFFSET)
            {
                uint writeId = offset++;
                if(!dryRun)
                {
                    uint lineEnd = y;

                    float v0 = (float(lineStart) + v0Offset) * invHeight;
                    float v1Offset = (middleVisible ? -UV_OFFSET_AMOUNT : UV_OFFSET_AMOUNT)
                                    - UV_OFFSET_BASE
                                    + UV_Y_OFFSET
                                    ;
                    float v1 = (float(lineEnd) + v1Offset) * invHeight;

                    outLines[writeId] = vec4(u, v0, u, v1);
                }
                lineStart = INVALID_OFFSET;
            }
        }
    }

    return offset;
}


uint evaluateCorners(uint tid,
                     uint offset,
                     MapAtlasLevelInfo atlasInfo,
                     bool dryRun)
{
    for(int y=0; y<atlasInfo.size.y; ++y)
    {
        for(int x=int(tid); x<atlasInfo.size.x; x+=THREAD_SIZE)
        {
            bool vis = sampleCoord(ivec2(x, y), atlasInfo);
            // if(!sampleCoord(ivec2(x, y), atlasInfo))
            {
                bvec4 corners = bvec4(sampleCoord(ivec2(x-1, y-1), atlasInfo) != vis,
                                      sampleCoord(ivec2(x-1, y+1), atlasInfo) != vis,
                                      sampleCoord(ivec2(x+1, y-1), atlasInfo) != vis,
                                      sampleCoord(ivec2(x+1, y+1), atlasInfo) != vis);

                if(!any(corners))
                {
                    continue;
                }
                
                bvec4 adjacent = bvec4(sampleCoord(ivec2(x-1, y), atlasInfo) != vis,
                                       sampleCoord(ivec2(x, y-1), atlasInfo) != vis,
                                       sampleCoord(ivec2(x+1, y), atlasInfo) != vis,
                                       sampleCoord(ivec2(x, y+1), atlasInfo) != vis);

                vec2 uvOffset = vis ? vec2(-UV_OFFSET_AMOUNT, UV_OFFSET_AMOUNT)
                                    : vec2(UV_OFFSET_AMOUNT, -UV_OFFSET_AMOUNT);
                
                if(corners.x && adjacent.x && adjacent.y)
                {
                    uint writeId = offset++;
                    if(!dryRun)
                    {
                        vec4 line = vec4(vec2(x, y + UV_Y_OFFSET).xyxy) + vec4(UV_OFFSET_BASE, 0, 0, UV_OFFSET_BASE) + uvOffset.xxxx;
                        outLines[writeId] = line * atlasInfo.inverseSize.xyxy;
                    }
                }
                if(corners.y && adjacent.x && adjacent.w)
                {
                    uint writeId = offset++;
                    if(!dryRun)
                    {
                        vec4 line = vec4(vec2(x, y + UV_Y_OFFSET).xyxy) + vec4(UV_OFFSET_BASE, 1, 0, UV_OFFSET_INVBASE) + uvOffset.xyxy;
                        outLines[writeId] = line * atlasInfo.inverseSize.xyxy;
                    }
                }
                if(corners.z && adjacent.z && adjacent.y)
                {
                    uint writeId = offset++;
                    if(!dryRun)
                    {
                        vec4 line = vec4(vec2(x, y + UV_Y_OFFSET).xyxy) + vec4(UV_OFFSET_INVBASE, 0, 1, UV_OFFSET_BASE) + uvOffset.yxyx;
                        outLines[writeId] = line * atlasInfo.inverseSize.xyxy;
                    }
                }
                if(corners.w && adjacent.z && adjacent.w)
                {
                    uint writeId = offset++;
                    if(!dryRun)
                    {
                        vec4 line = vec4(vec2(x, y + UV_Y_OFFSET).xyxy) + vec4(UV_OFFSET_INVBASE, 1, 1, UV_OFFSET_INVBASE) + uvOffset.yyyy;
                        outLines[writeId] = line * atlasInfo.inverseSize.xyxy;
                    }
                }
            }
        }
    }

    return offset;
}


void main()
{
    uint tid = gl_LocalInvocationID.x;
    uint level = globals.currentLevel;
    MapAtlasLevelInfo atlasInfo = getLevelAtlasInfo(level);

    lineAllocator[tid] = evaluateHorizontal(tid, 0, atlasInfo, true)
                       + evaluateVertical(tid, 0, atlasInfo, true)
                       + evaluateCorners(tid, 0, atlasInfo, true)
                        ;
    barrier();

    uint offset = 0;
    for(uint i=0; i<tid; ++i)
    {
        offset += lineAllocator[i];
    }

    offset = evaluateHorizontal(tid, offset, atlasInfo, false);
    offset = evaluateVertical(tid, offset, atlasInfo, false);
    offset = evaluateCorners(tid, offset, atlasInfo, false);


    if(tid == (THREAD_SIZE-1))
    {
        outNumLines = offset;
    }
}

