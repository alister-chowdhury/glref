#ifndef MAP_ATLAS_COMMON_GLSLI
#define MAP_ATLAS_COMMON_GLSLI


#define MAP_ATLAS_WALL_ID_NONE  0
#define MAP_ATLAS_WALL_ID_WALL  1
#define MAP_ATLAS_WALL_ID_FLOOR 2


#define MAP_ATLAS_WALL_DEPTH_NONE   0x0fff
#define MAP_ATLAS_WALL_DEPTH_WALL   0x0ff0
#define MAP_ATLAS_WALL_DEPTH_FLOOR  0x0fe0

#define MAX_ROOMS           32

#define FINAL_ATLAS_WIDTH   128
#define FINAL_ATLAS_HEIGHT  128

#define MAX_LEVEL_DIM       64

// There is always a 1px pading around the border
// as a result when we're using shared memory, we
// can limit the amount of resources needed.
#define MAX_LEVEL_DIM_SHARED_SIZE   62
#define MAX_LEVEL_DIM_SHARED_OFFSET 1


// Ids do a reasonably good job of seperating
// the start / and end rooms.
#define ENTER_ROOM_ID       1
#define EXIT_ROOM_ID        4


struct MapAtlasLevelInfo
{
    uvec2   offset;
    uvec2   size;
    vec2    inverseSize;
    uint    minDim;
    uint    minArea;
};


MapAtlasLevelInfo makeMapAtlasLevelInfo(uvec2 offset,
                                        uvec2 size,
                                        uint minDim,
                                        uint minArea)
{
    MapAtlasLevelInfo result;
    result.offset = offset;
    result.size = size;
    result.inverseSize = vec2(1.0) / vec2(size);
    result.minDim = minDim;
    result.minArea = minArea;
    return result;
}


// Swap this out with a buffer later?
MapAtlasLevelInfo getLevelAtlasInfo(uint level)
{
    switch(level & 7u)
    {
        case 0: return makeMapAtlasLevelInfo(uvec2(64, 84),
                                             uvec2(16, 16),
                                             2u,
                                             16u);
        case 1: return makeMapAtlasLevelInfo(uvec2(40, 64),
                                             uvec2(22, 22),
                                             3u,
                                             16u);
        case 2: return makeMapAtlasLevelInfo(uvec2(96, 81),
                                             uvec2(26, 26),
                                             3u,
                                             16u);
        case 3: return makeMapAtlasLevelInfo(uvec2(96, 52),
                                             uvec2(29, 29),
                                             3u,
                                             20u);
        case 4: return makeMapAtlasLevelInfo(uvec2(64, 52),
                                             uvec2(32, 32),
                                             4u,
                                             16u);
        case 5: return makeMapAtlasLevelInfo(uvec2(0, 64),
                                             uvec2(40, 40),
                                             4u,
                                             20u);
        case 6: return makeMapAtlasLevelInfo(uvec2(64, 0),
                                             uvec2(52, 52),
                                             4u,
                                             20u);
        case 7: return makeMapAtlasLevelInfo(uvec2(0, 0),
                                             uvec2(64, 64),
                                             5u,
                                             24u);
    }
}


// We store a maximum of 4 sectors per pixel, each
// using 8 bits, with the maximum value being 64.

uvec4 unpackSectorIds(uint atlasMask)
{
    return uvec4((atlasMask      ) & 0xffu,
                 (atlasMask >> 8 ) & 0xffu,
                 (atlasMask >> 16) & 0xffu,
                  atlasMask >> 24);
}

bool containsSingleSector(uint atlasMask,
                          uint sectorId)
{
    // We can use a zero byte in word test, to accelerate
    // testing:
    // https://graphics.stanford.edu/~seander/bithacks.html#ZeroInWord
    sectorId *= 0x01010101u;
    atlasMask ^= sectorId;
    atlasMask = ((atlasMask + 0x7efefeffu) ^ ~atlasMask) & 0x81010100u;
    // the 0x80 bit is never signed (we never have 128 sectors)
    // so we don't need to test for overflow.
    return atlasMask != 0u;
}



#endif // MAP_ATLAS_COMMON_GLSLI
