#ifndef MAP_ATLAS_COMMON_GLSLI
#define MAP_ATLAS_COMMON_GLSLI

#include "common.glsli"

#define MAX_ROOMS           32
#define FINAL_ATLAS_WIDTH   128
#define FINAL_ATLAS_HEIGHT  128
#define MAX_LEVEL_DIM       64


#define BACKGROUND_TILE_DIM     MAX_LEVEL_DIM


#define VIS_TILE_SIZE   8

// A room value of 0, is unassigned
#define ATLAS_ROOM_ID_EMPTY     0

// A value of [1, 32] is a room
#define ATLAS_ROOM_ID_BEGIN     1
#define ATLAS_ROOM_ID_LAST      32

// A value of [33, 63] is a path
#define ATLAS_PATH_ID_BEGIN     33
#define ATLAS_PATH_ID_LAST      63



// There is always a 1px pading around the border
// as a result when we're using shared memory, we
// can limit the amount of resources needed.
#define MAX_LEVEL_DIM_SHARED_SIZE   62
#define MAX_LEVEL_DIM_SHARED_OFFSET 1


#define packed_span_t   uint

#define packed_sector_ids_t  uint

#define sector_id_t     uint
#define sector_id_t2    uvec2
#define sector_id_t3    uvec3
#define sector_id_t4    uvec4


ivec4 unpackSpan(packed_span_t x)
{
    return ivec4((uvec4(x) >> ivec4(0, 8, 16, 24)) & 0xffu);
}


packed_span_t packSpan(ivec4 x)
{
    uvec4 y = uvec4(x) << ivec4(0, 8, 16, 24);
    return y.x | y.y | y.z | y.w;
}


struct MapAtlasLevelInfo
{
    uvec2   offset;
    uvec2   size;
    vec2    inverseSize;
    uint    minDim;
    uint    minArea;
};


MapAtlasLevelInfo makeMapAtlasLevelInfo(uvec2 offset,
                                        uvec2 size,
                                        uint minDim,
                                        uint minArea)
{
    MapAtlasLevelInfo result;
    result.offset = offset;
    result.size = size;
    result.inverseSize = vec2(1.0) / vec2(size);
    result.minDim = minDim;
    result.minArea = minArea;
    return result;
}


// Swap this out with a buffer later?
MapAtlasLevelInfo getLevelAtlasInfo(uint level)
{
    switch(level & 7u)
    {
        case 0: return makeMapAtlasLevelInfo(uvec2(64, 84),
                                             uvec2(16, 16),
                                             2u,
                                             16u);
        case 1: return makeMapAtlasLevelInfo(uvec2(40, 64),
                                             uvec2(22, 22),
                                             3u,
                                             16u);
        case 2: return makeMapAtlasLevelInfo(uvec2(96, 81),
                                             uvec2(26, 26),
                                             3u,
                                             16u);
        case 3: return makeMapAtlasLevelInfo(uvec2(96, 52),
                                             uvec2(29, 29),
                                             3u,
                                             20u);
        case 4: return makeMapAtlasLevelInfo(uvec2(64, 52),
                                             uvec2(32, 32),
                                             4u,
                                             16u);
        case 5: return makeMapAtlasLevelInfo(uvec2(0, 64),
                                             uvec2(40, 40),
                                             4u,
                                             20u);
        case 6: return makeMapAtlasLevelInfo(uvec2(64, 0),
                                             uvec2(52, 52),
                                             4u,
                                             20u);
        default:
        case 7: return makeMapAtlasLevelInfo(uvec2(0, 0),
                                             uvec2(64, 64),
                                             5u,
                                             24u);
    }
}


float getLevelToBackgroundScale(MapAtlasLevelInfo atlasInfo)
{
    return float(atlasInfo.size.x) / BACKGROUND_TILE_DIM;
}


float getBackgroundToLevelScale(MapAtlasLevelInfo atlasInfo)
{
    return atlasInfo.inverseSize.x * BACKGROUND_TILE_DIM;
}


vec2 levelUVToAtlasUV(vec2 levelUV, MapAtlasLevelInfo atlasInfo)
{
    vec2 offset = vec2(atlasInfo.offset) / vec2(FINAL_ATLAS_WIDTH, FINAL_ATLAS_HEIGHT);
    vec2 scale = vec2(atlasInfo.size) / vec2(FINAL_ATLAS_WIDTH, FINAL_ATLAS_HEIGHT);
    return levelUV * scale + offset;
}


#define MAP_ATLAS_LEVEL_DATA_NUM_ROOMS_OFFSET   0
#define MAP_ATLAS_LEVEL_DATA_START_ROOM_OFFSET  1
#define MAP_ATLAS_LEVEL_DATA_END_ROOM_OFFSET    2
#define MAP_ATLAS_LEVEL_DATA_ROOM_SPANS_OFFSET  3
#define MAP_ATLAS_LEVEL_DATA_STRIDE             (MAX_ROOMS + 3)

struct MapAtlasLevelData
{
    uint    numRooms;
    uint    startRoom;
    uint    endRoom;
    uint    packedRoomSpans[MAX_ROOMS];
};


// We store a maximum of 4 sectors per pixel, each
// using 8 bits, with the maximum value being 64.

sector_id_t4 unpackSectorIds(packed_sector_ids_t atlasMask)
{
    return sector_id_t4((atlasMask      ) & 0xffu,
                        (atlasMask >> 8 ) & 0xffu,
                        (atlasMask >> 16) & 0xffu,
                         atlasMask >> 24);
}


bool isSectorIdEmpty(sector_id_t idx) { return idx == ATLAS_ROOM_ID_EMPTY; }
bool isSectorIdRoom(sector_id_t idx) { return (idx >= ATLAS_ROOM_ID_BEGIN) && (idx <= ATLAS_ROOM_ID_LAST); }
bool isSectorIdPath(sector_id_t idx) { return (idx >= ATLAS_PATH_ID_BEGIN) && (idx <= ATLAS_PATH_ID_LAST); }

bool hasAnySectors(packed_sector_ids_t atlasMask)
{
    return atlasMask != (
        ATLAS_ROOM_ID_EMPTY
        | (ATLAS_ROOM_ID_EMPTY << 8)
        | (ATLAS_ROOM_ID_EMPTY << 16)
        | (ATLAS_ROOM_ID_EMPTY << 24)
    );;
}


// Checks if a atlas pixel contains a single sector id.
bool containsSingleSector(packed_sector_ids_t atlasMask,
                          sector_id_t sectorId)
{
    // We can use a zero byte in word test, to accelerate
    // testing:
    // https://graphics.stanford.edu/~seander/bithacks.html#ZeroInWord
    sectorId = permuteByte(sectorId);
    atlasMask ^= sectorId;
    atlasMask = ((atlasMask + 0x7efefeffu) ^ ~atlasMask) & 0x81010100u;
    // the 0x80 bit is never signed (we never have 128 sectors)
    // so we don't need to test for overflow.
    return atlasMask != 0u;
}


// Checks if two atlas pixels share a common secotr id.
bool containsSharedSector(packed_sector_ids_t am0,
                          packed_sector_ids_t am1)
{

    /// !!!!! NOT YET TESTED !!!!!

    // Todo: should probably check if branching
    //      num > 1,    evaluate second
    //      num > 2     svaluate third, forth
    //      accelerates things at runtime.

    // Prevent 0 to 0 compares, by writing 127 into the empty
    // cells of one of the inputs.
    uint invalidBitsStart = alignU32(findMSB(am1), 8);
    am1 |= (0x7f7f7f7fu << invalidBitsStart);

    // We can use a zero byte in word test, to accelerate
    // testing:
    // https://graphics.stanford.edu/~seander/bithacks.html#ZeroInWord
    uint x0 = permuteByte(am0, 0) ^ am1;
         x0 = ((x0 + 0x7efefeffu) ^ ~x0);

    uint x1 = permuteByte(am0, 1) ^ am1;
         x1 = ((x1 + 0x7efefeffu) ^ ~x1);

    uint x2 = permuteByte(am0, 2) ^ am1;
         x2 = ((x0 + 0x7efefeffu) ^ ~x2);

    uint x3 = permuteByte(am0, 3) ^ am1;
         x3 = ((x3 + 0x7efefeffu) ^ ~x3);

    x0 = (x0 | x1 | x2 | x3) & 0x81010100u;

    // the 0x80 bit is never signed (we never have 128 sectors)
    // so we don't need to test for overflow.
    return x0 != 0u;
}



#endif // MAP_ATLAS_COMMON_GLSLI
