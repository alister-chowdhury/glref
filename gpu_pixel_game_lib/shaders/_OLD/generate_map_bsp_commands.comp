#version 460 core


// TODO THIS IS ALL VERY MESSY


// NB: we can make more or simple maps, by adjusting:
//  threadsize
//  shared queue size
//  it cut off point
//
//  Can also bitshift the max tiles size
//
//
//  So it should be possible to generate more complicated maps
//  for later levels and siomple maps for early levels.
#define NUM_THREADS 64
layout(local_size_x=NUM_THREADS) in;


#include "common.glsli"


layout(set=0, binding = 0) uniform GlobalParameters_
{
    GlobalParameters globals;
}; 



// SHOULD BE IN ANOTHER SET FOR VULKAN THINGS
writeonly layout(std430, binding = 1) buffer drawCmds_      { vec4 outDrawCmds[]; };
writeonly layout(std430, binding = 2) buffer drawAllocator_ { uint outDrawAllocator[]; };


#define MAX_TILES_X 64
#define MAX_TILES_Y 64

#define MIN_DIM_X   5
#define MIN_DIM_Y   5
#define MIN_AREA    24

#define PADDING 1

#define INVERSE_TILE_SIZE (vec2(1.0) / vec2(MAX_TILES_X, MAX_TILES_Y))

struct DrawQueue
{
    ivec4 span;

    /// TODO
    //  add flags to spawn playerand exit into rooms, passing
    //  the flag down to the lowest leaf
    // int spawnPlayer;
    // int spawnExit;
};

shared uint         drawAllocator;
shared DrawQueue    queue[64];


// Uses the last 23bits to construct a linear range
// [0, 1) = [0.375, 0.625)
float randomBounded0125(uint seed)
{
    // 1x shift_add
    // 1x add
    seed = 0x3e800000u + (seed & 0x7fffffu);
    return uintBitsToFloat(seed) + 0.125f;
}



void main()
{
    uint tid = gl_LocalInvocationID.x;
    if(tid == 0u)
    {
        drawAllocator = 0u;

        DrawQueue newQueue;
        newQueue.span = ivec4(0, 0, MAX_TILES_X, MAX_TILES_Y);
        queue[0] = newQueue;
    }
    barrier();

    for(uint it=1u; it<NUM_THREADS; it<<=1)
    {
        if(tid < it)
        {
            DrawQueue parent = queue[tid];
            uint seed = simpleHash32(uvec3(globals.randomSeed, it, tid));
            float splitAmount = randomBounded0125(seed);
                                seed >>= 23;
            ivec2 wh = parent.span.zw - parent.span.xy;

            // Randomise split direction, unless it's REALLY imbalanced
            uint direction = seed & 1u;
            if((wh.x ) < wh.y)
            {
                direction = 1;
            }
            else if((wh.y ) < wh.x)
            {
                direction = 0;
            }


            DrawQueue left = parent;
            DrawQueue right = parent;

            if(direction == 0)
            {
                left.span.z = left.span.x + int((float(wh.x) + 0.5) * splitAmount);
                right.span.x = left.span.z;
                left.span.x += PADDING;
                left.span.z -= PADDING;
                right.span.x += PADDING;
                right.span.z -= PADDING;

            }
            else
            {
                left.span.w = left.span.y + int((float(wh.y) + 0.5) * splitAmount);
                right.span.y = left.span.w;
                left.span.y += PADDING;
                left.span.w -= PADDING;
                right.span.y += PADDING;
                right.span.w -= PADDING;
            }

            ivec2 leftDeriv = left.span.zw - left.span.xy;
            ivec2 rightDeriv = right.span.zw - right.span.xy;
            int leftArea = leftDeriv.x * leftDeriv.y;
            int rightArea = rightDeriv.x * rightDeriv.y;

            if((leftDeriv.x >= MIN_DIM_X)
                && (leftDeriv.y >= MIN_DIM_Y)
                && (rightDeriv.x >= MIN_DIM_X)
                && (rightDeriv.y >= MIN_DIM_Y)
                && (leftArea >= MIN_AREA)
                && (rightArea >= MIN_AREA))
            {
                // Split the BSP node and write back a path that connects
                // both their centers.
                uint pathsIndex = atomicAdd(drawAllocator, 1u);

                queue[tid] = left;

                vec2 leftCenter = vec2(left.span.xy)
                                  + vec2(leftDeriv) * 0.5
                                  + 0.5
                                  ;

                vec2 rightCenter = vec2(right.span.xy)
                                  + vec2(rightDeriv) * 0.5
                                  + 0.5
                                  ;

                vec4 path = (direction == 0)
                    ? vec4(vec2(leftCenter.x, rightCenter.y), rightCenter + 1.0)
                    : vec4(leftCenter, vec2(leftCenter.x, rightCenter.y) + 1.0)
                    ;

                outDrawCmds[pathsIndex] = path * INVERSE_TILE_SIZE.xyxy;

            }
            else
            {
                // Leave the parents data (left node) alone, either it will be split
                // the next iteration, or it will become a leaf.
                right.span = ivec4(0, 0, 0, 0);
            }

            queue[it + tid] = right;

        }
        barrier();
    }

    {
        DrawQueue leaf = queue[tid];

        if(leaf.span.x != leaf.span.z)
        {

            // Handle writing out players, loot, enemies, exit etc

            uint roomIndex = atomicAdd(drawAllocator, 1u);
            outDrawCmds[roomIndex] = vec4(leaf.span) * INVERSE_TILE_SIZE.xyxy;
        }
    }

    barrier();

    if(tid == 0u)
    {
        outDrawAllocator[0] = drawAllocator * 6u;
    }
}
