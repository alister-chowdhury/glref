#ifndef GAME_LOGIC_COMMON_GLSLI
#define GAME_LOGIC_COMMON_GLSLI


#include "../../shaders/common.glsl"
#include "global_parameters.glsli"


// TODO: GPU specific permutations
#ifndef TARGET_AMD
#define TARGET_AMD 0
#endif // TARGET_AMD

#ifndef TARGET_NVIDIA
#define TARGET_NVIDIA 0
#endif // TARGET_NVIDIA


uint simpleHash32(uvec3 seed)
{
    uint hx = (0xb543c3a6u ^ seed.x);
    uint hy = (0x526f94e2u ^ seed.y);
    uint hxy = hx * hy;
    uint hz0 = 0x53c5ca59u ^ (hxy >> 5u);
    uint hz1 = (0x74743c1bu ^ seed.z);
    uint h = hz0 * hz1;
    return h;
}


uint simpleHash32_u2v0(uvec2 seed)
{
    uint hx = (seed.x ^ 0xcac9442u);
    uint hy = (seed.y ^ 0x526ed7c6u);
    uint hz = (hx * hy) ^ 0xc4ab2ac2u;
    return hz * 0x526f94e3u;
}

uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}


vec3 hs1(float H)
{
    float R = abs(H * 6 - 3) - 1;
    float G = 2 - abs(H * 6 - 2);
    float B = 2 - abs(H * 6 - 4);
    return clamp(vec3(R,G,B), vec3(0), vec3(1));
}


vec3 randomHs1Col(uint idx)
{
    return hs1((wang_hash(idx) & 0xffff) / 65535.0);
}


// Uses the last 23bits to construct a linear range
// [0, 1) = [0, 0.9999998808]
float randomBounded(uint seed)
{
    // 1x shift_add
    // 1x add
    seed = 0x3f800000u + (seed & 0x7fffffu);
    return uintBitsToFloat(seed) - 1.0f;
}


uint permuteByte(uint byte)
{

#if TARGET_AMD || TARGET_NVIDIA

    // v_perm_b32 / prmt.b32
    byte &= 0xffu;
    byte = byte | (byte << 8);
    byte = byte | (byte << 16);

#else // TARGET_AMD || TARGET_NVIDIA

    byte *= 0x01010101u;

#endif // TARGET_AMD || TARGET_NVIDIA

    return byte;
}


uint permuteByte(uint byte, uint index)
{
    return permuteByte((byte >> (index * 8u)) & 0xffu);
}


uint alignU32(uint x, uint a)
{
    // Should be two full rate instructions, assuming
    // a is valid 
    uint m = a - 1;
    return (x + m) & ~m;
}

#endif // GAME_LOGIC_COMMON_GLSLI
