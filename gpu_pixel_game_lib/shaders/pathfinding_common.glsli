#ifndef PATHFINDING_COMMON_GLSLI
#define PATHFINDING_COMMON_GLSLI

// Rather than using A* and friends, we store a series of directions,
// 2 bits per room, (LEFT, UP, RIGHT, DOWN), so when it comes to updating
// the AI, it's basically O(1).
// The limitations of this are that we never really know the total distance
#include "common.glsli"
#include "bindings.glsli"
#include "map_atlas_common.glsli"

#define PATHFINDING_LEFT    0
#define PATHFINDING_DOWN    1
#define PATHFINDING_RIGHT   2
#define PATHFINDING_UP      3

#define PATHFINDING_LEFT_MASK    0
#define PATHFINDING_DOWN_MASK    0x55555555
#define PATHFINDING_RIGHT_MASK   0xaaaaaaaa
#define PATHFINDING_UP_MASK      0xffffffff


ivec2 decodePathDirection(uint idx)
{
    // .x =-1  0, 1, 0
    // .y = 0,-1, 0, 1
    // Either [LEFT, DOWN] or [RIGHT, UP]
    int side = -1 + int(idx & 2u);
    // 0 = x, 1 = y
    uint axis = idx & 1u;
    return axis == 0u ? ivec2(side, 0) : ivec2(0, side); 
}


ivec2 calcDirectionCoordForRoom(ivec2 atlasCoord,
                                uint roomId)
{
    atlasCoord.x *= 2;
    if(roomId >= 33)
    {
        atlasCoord.x += 1;
    }
    return atlasCoord;
}


uint extractDirectionToRoom(uvec2 mask,
                            uint roomId)
{
    --roomId;
    roomId &= 31u;
    if(roomId >= 16u)
    {
        mask.x = mask.y;
        roomId -= 16u;
    }
    return (mask.x >> (roomId * 2u)) & 3u;
}


uint getDirectionToRoom(ivec2 atlasCoord, uint roomId)
{

    ivec2 directionCoord = calcDirectionCoordForRoom(atlasCoord, roomId).xy;
    uvec2 mask = imageLoad(roomDirectionsImage, directionCoord).xy;
    return extractDirectionToRoom(mask, roomId);
}


// Requires mapAtlas
vec2 calcPathfindingDirection(vec2 srcAtlasUV,
                              vec2 dstAtlasUV)
{
    bool smoothDirection = false;
    vec2 delta = dstAtlasUV - srcAtlasUV;
    float distSq = dot(delta, delta);
    if(distSq < 1e-9)
    {
        return delta;
    }

    ivec2 srcCoord = ivec2(srcAtlasUV * vec2(FINAL_ATLAS_WIDTH, FINAL_ATLAS_HEIGHT));
    ivec2 dstCoord = ivec2(dstAtlasUV * vec2(FINAL_ATLAS_WIDTH, FINAL_ATLAS_HEIGHT));

    packed_sector_ids_t srcPacked = imageLoad(mapAtlas, srcCoord).x;
    packed_sector_ids_t dstPacked = imageLoad(mapAtlas, dstCoord).x;

    if(!hasAnySectors(srcPacked) || !hasAnySectors(dstPacked))
    {
        return vec2(0);
    }
    else if(!containsSharedSector(srcPacked, dstPacked))
    {
        uint roomId = unpackSectorIds(dstPacked).x;
        ivec2 direction = decodePathDirection(getDirectionToRoom(srcCoord, roomId));
        if(smoothDirection)
        {
            srcCoord += direction;
            srcPacked = imageLoad(mapAtlas, srcCoord).x;
            if(hasAnySectors(srcPacked)
                && !containsSharedSector(srcPacked, dstPacked))
            {
                ivec2 newDirecton = direction
                                  + decodePathDirection(getDirectionToRoom(srcCoord, roomId));

                if(newDirecton.x != 0 && newDirecton.y != 0)
                {
                    direction = newDirecton;
                }
            }
        }

        delta = vec2(direction);
        distSq = dot(delta, delta);
    }

    delta *= inversesqrt(distSq);
    return delta;
}


#endif // PATHFINDING_COMMON_GLSLI
