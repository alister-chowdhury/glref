#ifndef PATHFINDING_COMMON_GLSLI
#define PATHFINDING_COMMON_GLSLI

// Rather than using A* and friends, we store a series of directions,
// 2 bits per room, (LEFT, UP, RIGHT, DOWN), so when it comes to updating
// the AI, it's basically O(1).
// The limitations of this are that we never really know the total distance
#include "common.glsli"
#include "bindings.glsli"
#include "map_atlas_common.glsli"

#define PATHFINDING_LEFT    0
#define PATHFINDING_DOWN    1
#define PATHFINDING_RIGHT   2
#define PATHFINDING_UP      3

#define PATHFINDING_LEFT_MASK    0
#define PATHFINDING_DOWN_MASK    0x55555555
#define PATHFINDING_RIGHT_MASK   0xaaaaaaaa
#define PATHFINDING_UP_MASK      0xffffffff


ivec2 decodePathDirection(uint idx)
{
    // .x =-1  0, 1, 0
    // .y = 0,-1, 0, 1
    // Either [LEFT, DOWN] or [RIGHT, UP]
    int side = -1 + int(idx & 2u);
    // 0 = x, 1 = y
    uint axis = idx & 1u;
    return axis == 0u ? ivec2(side, 0) : ivec2(0, side); 
}


ivec2 calcDirectionCoordForRoom(ivec2 atlasCoord,
                                uint roomId)
{
    atlasCoord.x *= 2;
    if(roomId >= 33)
    {
        atlasCoord.x += 1;
    }
    return atlasCoord;
}


uint extractDirectionToRoom(uvec2 mask,
                            uint roomId)
{
    --roomId;
    roomId &= 31u;
    if(roomId >= 16u)
    {
        mask.x = mask.y;
        roomId -= 16u;
    }
    return (mask.x >> (roomId * 2u)) & 3u;
}


uint getDirectionToRoom(ivec2 atlasCoord, uint roomId)
{

    ivec2 directionCoord = calcDirectionCoordForRoom(atlasCoord, roomId).xy;
    uvec2 mask = imageLoad(roomDirectionsImage, directionCoord).xy;
    return extractDirectionToRoom(mask, roomId);
}


// Requires mapAtlas
vec2 calcPathfindingDirection(vec2 srcAtlasUV,
                              vec2 dstAtlasUV)
{
    bool smoothDirection = false; // todo, they get trapped on walls
                                  // need to do a df trace or something
    vec2 delta = vec2(0);
    float distSq = 0;

    ivec2 srcCoord = ivec2(srcAtlasUV * vec2(FINAL_ATLAS_WIDTH, FINAL_ATLAS_HEIGHT));
    ivec2 dstCoord = ivec2(dstAtlasUV * vec2(FINAL_ATLAS_WIDTH, FINAL_ATLAS_HEIGHT));

    packed_sector_ids_t srcPacked = imageLoad(mapAtlas, srcCoord).x;
    packed_sector_ids_t dstPacked = imageLoad(mapAtlas, dstCoord).x;

    if(!hasAnySectors(srcPacked) || !hasAnySectors(dstPacked))
    {
        return vec2(0);
    }
    else if(!containsSharedSector(srcPacked, dstPacked))
    {
        uint roomId = unpackSectorIds(dstPacked).x;
        ivec2 direction = decodePathDirection(getDirectionToRoom(srcCoord, roomId));
        delta = vec2(direction);
        distSq = dot(delta, delta);
    }
    else
    {
        delta = dstAtlasUV - srcAtlasUV;
        distSq = dot(delta, delta);
    }
    if(distSq > 0)
    {
        delta *= inversesqrt(distSq);
    }
    return delta;
}


vec2 calcPathfindingDirectionSmooth(vec2 srcAtlasUV,
                                    vec2 dstAtlasUV)
{
    srcAtlasUV *= vec2(FINAL_ATLAS_WIDTH, FINAL_ATLAS_HEIGHT);
    dstAtlasUV *= vec2(FINAL_ATLAS_WIDTH, FINAL_ATLAS_HEIGHT);

    // Prevent attempting to walk through walls at a grazing angle.
    // Bit of a hack, but what in life isn't?
    srcAtlasUV -= vec2(0, 0.25);
    dstAtlasUV -= vec2(0, 0.25);

    packed_sector_ids_t dstPacked = imageLoad(mapAtlas, ivec2(dstAtlasUV)).x;

    if(!hasAnySectors(dstPacked))
    {
        return vec2(0);
    }

    uint roomId = unpackSectorIds(dstPacked).x;

    vec2 delta = dstAtlasUV - srcAtlasUV;
    float deltaDistSq = dot(delta, delta);
    if(deltaDistSq > 1)
    {
        delta *= inversesqrt(deltaDistSq);
    }

    vec4 interp = vec4(0, 0, fract(srcAtlasUV));
    interp.xy = vec2(1) - interp.zw;

    ivec2 srcCoordBase = ivec2(srcAtlasUV);

    vec2 direction = vec2(0);

    for(int dXY = 0; dXY < 4; ++dXY)
    {
        int dX = dXY & 1;
        int dY = dXY >> 1;
        ivec2 srcCoord = srcCoordBase + ivec2(dX, dY);
        packed_sector_ids_t srcPacked = imageLoad(mapAtlas, srcCoord).x;
        if(hasAnySectors(srcPacked))
        {
            float weight = ((dX == 0) ? interp.x : interp.z)
                         * ((dY == 0) ? interp.y : interp.w);
            if(containsSharedSector(srcPacked, dstPacked))
            {
                direction += delta * weight;
            }
            else
            {

                uint directionType = getDirectionToRoom(srcCoord, roomId);
                direction += vec2(decodePathDirection(directionType)) * weight;
            }
        }
    }

    float distSq = dot(direction, direction);
    if(distSq == 0)
    {
        direction = delta; // get out of walls!
        distSq = dot(direction, direction);
    }

    if(distSq > 0)
    {
        direction *= inversesqrt(distSq);
    }
    return direction;
}

#endif // PATHFINDING_COMMON_GLSLI
