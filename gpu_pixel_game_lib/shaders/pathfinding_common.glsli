#ifndef PATHFINDING_COMMON_GLSLI
#define PATHFINDING_COMMON_GLSLI

// Rather than using A* and friends, we store a series of directions,
// 2 bits per room, (LEFT, UP, RIGHT, DOWN), so when it comes to updating
// the AI, it's basically O(1).
// The limitations of this are that we never really know the total distance
#include "bindings.glsli"

#define PATHFINDING_LEFT    0
#define PATHFINDING_DOWN    1
#define PATHFINDING_RIGHT   2
#define PATHFINDING_UP      3

#define PATHFINDING_LEFT_MASK    0
#define PATHFINDING_DOWN_MASK    0x55555555
#define PATHFINDING_RIGHT_MASK   0xaaaaaaaa
#define PATHFINDING_UP_MASK      0xffffffff


ivec2 decodePathDirection(uint idx)
{
    // .x =-1  0, 1, 0
    // .y = 0,-1, 0, 1
    // Either [LEFT, DOWN] or [RIGHT, UP]
    int side = -1 + int(idx & 2u);
    // 0 = x, 1 = y
    uint axis = idx & 1u;
    return axis == 0u ? ivec2(side, 0) : ivec2(0, side); 
}


ivec2 calcDirectionCoordForRoom(ivec2 atlasCoord,
                                uint roomId)
{
    atlasCoord.x *= 2;
    if(roomId >= 33)
    {
        atlasCoord.x += 1;
    }
    return atlasCoord;
}


uint extractDirectionToRoom(uvec2 mask,
                            uint roomId)
{
    --roomId;
    roomId &= 31u;
    if(roomId >= 16u)
    {
        mask.x = mask.y;
        roomId -= 16u;
    }
    return (mask.x >> (roomId * 2u)) & 3u;
}


uint getDirectionToRoom(ivec2 atlasCoord, uint roomId)
{

    ivec2 directionCoord = calcDirectionCoordForRoom(atlasCoord, roomId).xy;
    uvec2 mask = imageLoad(roomDirectionsImage, directionCoord).xy;
    return extractDirectionToRoom(mask, roomId);
}

#endif // PATHFINDING_COMMON_GLSLI
